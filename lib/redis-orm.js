// Generated by CoffeeScript 1.4.0
(function() {
  var RORMRef, RedisORM,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RORMRef = (function() {

    function RORMRef(rorm_ref) {
      this.rorm_ref = rorm_ref;
    }

    return RORMRef;

  })();

  RedisORM = (function(_super) {
    var NO_REDIS_URL;

    __extends(RedisORM, _super);

    function RedisORM() {
      return RedisORM.__super__.constructor.apply(this, arguments);
    }

    NO_REDIS_URL = new Error("No url configured for RedisORM mixin!");

    RedisORM.addTheseToClass = {
      /*
          #   Some Constants
      */

      rorm_delim: ':',
      rorm_prefix: 'rorm:',
      rorm_TYPE_OBJECT: 'object',
      rorm_TYPE_FUNCTION: 'function',
      rorm_CLASS_ARRAY: 'Array',
      /*
          #   db
          #   returns a redis client bound to redisURL:dbNum
          #   the redis client can is cached globally by redisURL:dbNum
          #   defaults redisURL to redis::localhost:6379
          #   defaults dbNum to 0
      */

      rorm_redis: function() {
        var dbNum, lookup, url;
        if (this.mixinConfig.client != null) {
          return this.mixinConfig.client;
        }
        url = this.mixinConfig.url || global.redisURL || global.REDIS_URL || process.env.REDIS_URL || process.env.REDISTOGO_URL || 'redis://127.0.0.1:6379/';
        dbNum = this.mixinConfig.dbNum || global.dbNum || 0;
        lookup = "" + url + "[" + dbNum + "]";
        global.rorm_redisClients || (global.rorm_redisClients = {});
        return rorm_redisClients[lookup] || (rorm_redisClients[lookup] = (require('redis-url')).connect(url).select(dbNum));
      },
      find: function(id, callback) {
        var klazz, refKey;
        refKey = this.rorm_refKeyForID(id);
        klazz = this;
        return this.rorm_redis().hgetall(refKey, function(err, data) {
          var k, v, x;
          x = new klazz;
          for (k in data) {
            if (!__hasProp.call(data, k)) continue;
            v = data[k];
            klazz.rorm_resolveValue(x, k, v);
          }
          return callback(err, x);
        });
      },
      rorm_resolveValue: function(obj, key, val) {
        var v;
        v = JSON.parse(val);
        if ('string' === typeof v && v.startsWith('rorm')) {
          return obj[key] = '+++ deref: ' + v;
        } else {
          return obj[key] = v;
        }
      },
      /*
          #   deepSaveAtts
          #   deeply stores the all object atts to redis using:
          #   REDIS.HMSET key, att1, val1 [,att2, val2 ...]
          #   return: redis key
      */

      rorm_deepSaveAtts: function(model) {
        var atts, redisArgs, redisAtts, _ref;
        atts = this.rorm_attsForModel(model);
        redisAtts = this.rorm_deepSaveRefs(atts);
        redisArgs = this.rorm_argsForHMSET(model.rorm_refKey(), redisAtts);
        (_ref = this.rorm_redis()).hmset.apply(_ref, redisArgs);
        return redisArgs[0];
      },
      rorm_deepSaveArrayValues: function(array) {
        var item, x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          x = array[_i];
          _results.push(item = (typeof x.save === "function" ? x.save() : void 0) || x);
        }
        return _results;
      },
      rorm_deepSaveHashValues: function(hash) {
        var _this = this;
        return mapOfHash(hash, function(key, val) {
          return [key, (typeof val.save === "function" ? val.save() : void 0) || val];
        });
      },
      /* 
      #   rorm_argsForHMSET
      #   prepars an argument array for call to:
      #   REDIS.HMSET key field value [field value ...]
      */

      rorm_argsForHMSET: function(redisKey, atts) {
        var args, k, v;
        args = [];
        args.push(redisKey);
        for (k in atts) {
          if (!__hasProp.call(atts, k)) continue;
          v = atts[k];
          args.push(k, JSON.stringify(v));
        }
        return args;
      },
      rorm_refKeyForModel: function(model) {
        return this.rorm_refKeyForID(model.id, model.constructor.name);
      },
      rorm_refKeyForID: function(id, className) {
        className || (className = this.name);
        return this.rorm_prefix + className + this.rorm_delim + id;
      },
      rorm_attsForModel: function(model) {
        var _this = this;
        return subsetOfHash(model, function(key, value) {
          return !(key.startsWith('rorm_')) && (typeof value !== _this.rorm_TYPE_FUNCTION);
        });
      },
      rorm_deepSaveRefs: function(atts) {
        var _this = this;
        return mapOfHash(atts, function(key, val) {
          var mappedValue;
          if (val instanceof Array) {
            mappedValue = _this.rorm_deepSaveArrayValues(val);
          } else {
            mappedValue = (typeof val.save === "function" ? val.save() : void 0) || val;
          }
          return [key, mappedValue];
        });
      }
    };

    RedisORM.addTheseToInstance = {
      rorm_NO_ID: new Error("No id"),
      rorm_class: function() {
        return this.constructor;
      },
      rorm_refKey: function() {
        return this.rorm_class().rorm_refKeyForModel(this);
      },
      /*
          #   save
          #   stores the object's state in redis
          #   an @id is auto generated if one isn't set already
          #   return: redis key
          #   creates a key based on @id, and saves the object into redis
          #   values are saved as json
          #   refs as redis keys to the object (which all start with the rorm_prefix)
      */

      save: function() {
        if (!this.id) {
          throw this.rorm_NO_ID;
        }
        return this.rorm_class().rorm_deepSaveAtts(this);
      },
      /*
          #   toHash
          #   copy of all the model's attributes
      */

      toHash: function() {
        return this.rorm_class().rorm_attsForModel(this);
      },
      toJSON: function() {
        return JSON.stringify(this.toHash());
      },
      toEvent: function() {
        var atts, fieldName, _i, _len, _ref;
        atts = this.toHash();
        if (this.privateFields != null) {
          _ref = this.privateFields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            fieldName = _ref[_i];
            delete atts[fieldName];
          }
        }
        return atts;
      },
      emitTo: function(channel) {
        var _ref, _ref1;
        if (((_ref = channel.manager) != null ? (_ref1 = _ref.settings) != null ? _ref1.transports : void 0 : void 0) != null) {
          return channel.emit(this.className(), this.toEvent());
        } else {
          return channel.emit(this.className(), this);
        }
      }
    };

    return RedisORM;

  })(Mixin);

  global.RedisORM = RedisORM;

}).call(this);
