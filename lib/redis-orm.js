// Generated by CoffeeScript 1.4.0
(function() {
  var RedisORM, async,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  async = require('async');

  global.rorm_redisClients || (global.rorm_redisClients = {});

  RedisORM = (function(_super) {
    var NO_REDIS_URL;

    __extends(RedisORM, _super);

    function RedisORM() {
      return RedisORM.__super__.constructor.apply(this, arguments);
    }

    NO_REDIS_URL = new Error("No url configured for RedisORM mixin!");

    RedisORM.addTheseToClass = {
      /*
          #   Some Constants
      */

      rorm_delim: ':',
      rorm_prefix: 'rorm:',
      rorm_TYPE_OBJECT: 'object',
      rorm_TYPE_FUNCTION: 'function',
      rorm_CLASS_ARRAY: 'Array',
      /*
          #   Some Error Constants
      */

      rorm_NO_ID: new Error("No id"),
      /*
          #   db
          #   returns a redis client bound to redisURL:dbNum
          #   the redis client can is cached globally by redisURL:dbNum
          #   defaults redisURL to redis::localhost:6379
          #   defaults dbNum to 0
      */

      rorm_redis: function() {
        var dbNum, lookup, url;
        if (this.mixinConfig.client != null) {
          return this.mixinConfig.client;
        }
        url = this.mixinConfig.url || global.redisURL || global.REDIS_URL || process.env.REDIS_URL || process.env.REDISTOGO_URL || 'redis://127.0.0.1:6379/';
        dbNum = this.mixinConfig.dbNum || global.dbNum || 0;
        lookup = "" + url + "[" + dbNum + "]";
        return rorm_redisClients[lookup] || (rorm_redisClients[lookup] = (require('redis-url')).connect(url).select(dbNum));
      },
      configureRedisORM: function(configs) {
        var key, val, _results;
        _results = [];
        for (key in configs) {
          if (!__hasProp.call(configs, key)) continue;
          val = configs[key];
          _results.push(this.mixinConfig[key] = val);
        }
        return _results;
      },
      materialize: function(id, callback) {},
      find: function(id, callback) {
        var refKey;
        refKey = this.rorm_refKeyForID(id);
        return this.rorm_findByRefKey(refKey, callback);
      },
      rorm_classForRefKey: function(key) {
        var className;
        className = key.split(':')[1];
        return global[className];
      },
      rorm_findByRefKey: function(key, callback) {
        var _this = this;
        return this.rorm_redis().hgetall(key, function(err, data) {
          var k, klazz, resolveFunctorFor, resolvers, v, x;
          if (data == null) {
            return callback(err, null);
          }
          klazz = _this.rorm_classForRefKey(key);
          x = new klazz;
          resolvers = [];
          resolveFunctorFor = function(x, k, v) {
            return function(cb) {
              return x.rorm_resolveJSONValue(k, v, cb);
            };
          };
          for (k in data) {
            if (!__hasProp.call(data, k)) continue;
            v = data[k];
            resolvers.push(resolveFunctorFor(x, k, v));
          }
          return async.series(resolvers, function(err, results) {
            return callback(err, x);
          });
        });
      },
      save: function(model, callback) {
        if (!model.id) {
          throw this.rorm_NO_ID;
        }
        return this.rorm_deepSaveAtts(model, callback);
      },
      destroy: function(model, callback) {
        var key,
          _this = this;
        if (!model.id) {
          throw this.rorm_NO_ID;
        }
        key = model.rorm_refKey();
        this.rorm_redis().del(key, function(err, ok) {
          if (callback) {
            return callback(err, key);
          }
        });
        return key;
      },
      /*
          #   deepSaveAtts
          #   deeply stores the all object atts to redis using:
          #   REDIS.HMSET key, att1, val1 [,att2, val2 ...]
          #   return: redis key
      */

      rorm_deepSaveAtts: function(model, callback) {
        var atts, redisArgs, redisAtts, _ref,
          _this = this;
        atts = this.rorm_attsForModel(model);
        redisAtts = this.rorm_deepSaveRefs(atts);
        redisArgs = this.rorm_argsForHMSET(model.rorm_refKey(), redisAtts);
        (_ref = this.rorm_redis()).hmset.apply(_ref, __slice.call(redisArgs).concat([function(err, ok) {
          if (callback != null) {
            return callback(err, redisArgs[0]);
          }
        }]));
        return redisArgs[0];
      },
      rorm_deepSaveArrayValues: function(array) {
        var item, x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          x = array[_i];
          _results.push(item = (typeof x.save === "function" ? x.save() : void 0) || x);
        }
        return _results;
      },
      rorm_deepSaveHashValues: function(hash) {
        var _this = this;
        return mapOfHash(hash, function(key, val) {
          return [key, (typeof val.save === "function" ? val.save() : void 0) || val];
        });
      },
      /* 
      #   rorm_argsForHMSET
      #   prepars an argument array for call to:
      #   REDIS.HMSET key field value [field value ...]
      */

      rorm_argsForHMSET: function(redisKey, atts) {
        var args, k, v;
        args = [];
        args.push(redisKey);
        for (k in atts) {
          if (!__hasProp.call(atts, k)) continue;
          v = atts[k];
          args.push(k, JSON.stringify(v));
        }
        return args;
      },
      rorm_refKeyForModel: function(model) {
        return this.rorm_refKeyForID(model.id, model.constructor.name);
      },
      rorm_refKeyForID: function(id, className) {
        className || (className = this.name);
        return this.rorm_prefix + className + this.rorm_delim + id;
      },
      rorm_attsForModel: function(model) {
        var _this = this;
        return subsetOfHash(model, function(key, value) {
          return !(key.startsWith('rorm_')) && (typeof value !== _this.rorm_TYPE_FUNCTION);
        });
      },
      rorm_deepSaveRefs: function(atts) {
        var _this = this;
        return mapOfHash(atts, function(key, val) {
          var mappedValue;
          if (val === null) {
            return [key, null];
          }
          if (val === void 0) {
            return [key, void 0];
          }
          if (val instanceof Array) {
            mappedValue = _this.rorm_deepSaveArrayValues(val);
          } else {
            mappedValue = (typeof val.save === "function" ? val.save() : void 0) || val;
          }
          return [key, mappedValue];
        });
      }
    };

    RedisORM.addTheseToInstance = {
      rorm_class: function() {
        return this.constructor;
      },
      rorm_refKey: function() {
        return this.rorm_class().rorm_refKeyForModel(this);
      },
      rorm_resolveJSONValue: function(key, val, callback) {
        var v,
          _this = this;
        v = void 0;
        try {
          v = JSON.parse(val);
        } catch (e) {
          v = void 0;
        }
        if ('string' === typeof v && v.startsWith('rorm')) {
          console.log("-- looking up ref:", v);
          return this.rorm_class().rorm_findByRefKey(v, function(err, ref) {
            _this[key] = ref;
            return callback(null, _this[key]);
          });
        } else {
          this[key] = v;
          console.log('set', key, v);
          return callback(null, this[key]);
        }
      },
      /*
          #   save
          #   stores the object's state in redis
          #   an @id is auto generated if one isn't set already
          #   return: redis key
          #   creates a key based on @id, and saves the object into redis
          #   values are saved as json
          #   refs as redis keys to the object (which all start with the rorm_prefix)
      */

      save: function(callback) {
        return this.rorm_class().save(this, callback);
      },
      destroy: function(callback) {
        return this.rorm_class().destroy(this, callback);
      },
      /*
          #   toHash
          #   copy of all the model's attributes
      */

      toHash: function() {
        return this.rorm_class().rorm_attsForModel(this);
      },
      toJSON: function() {
        return JSON.stringify(this.toHash());
      },
      toEvent: function() {
        var atts, fieldName, _i, _len, _ref;
        atts = this.toHash();
        if (this.privateFields != null) {
          _ref = this.privateFields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            fieldName = _ref[_i];
            delete atts[fieldName];
          }
        }
        return atts;
      },
      emitTo: function(channel) {
        var _ref, _ref1;
        if (((_ref = channel.manager) != null ? (_ref1 = _ref.settings) != null ? _ref1.transports : void 0 : void 0) != null) {
          return channel.emit(this.className(), this.toEvent());
        } else {
          return channel.emit(this.className(), this);
        }
      }
    };

    return RedisORM;

  })(Mixin);

  global.RedisORM = RedisORM;

}).call(this);
