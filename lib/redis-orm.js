// Generated by CoffeeScript 1.4.0
(function() {
  var NOT_A_MODEL, NO_ID, NO_REDIS_URL, RedisORM, TYPE_FUNCTION, async, resolveJSONFunctorFor, resolveValueFunctorFor,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  async = require('async');

  global.rorm_redisClients || (global.rorm_redisClients = {});

  /*
  #   Some Constants
  */


  TYPE_FUNCTION = 'function';

  /*
  #   Some Error Constants
  */


  NO_ID = new Error("No id!");

  NOT_A_MODEL = new Error("Object is not a Redis ORM model!");

  NO_REDIS_URL = new Error("No url configured for RedisORM mixin!");

  /*
  #   Resolve JSON Functor
  #   Convert redis value (stored as json) into js attribute, array, hash, or model
  #   obj: The object that will have its key set to the resolved value
  */


  resolveJSONFunctorFor = function(klazz, val, obj, key) {
    return function(cb) {
      return klazz.rorm_resolveJSONValue(val, function(err, resolvedValue) {
        if ((obj != null) && (key != null)) {
          obj[key] = resolvedValue;
        }
        return cb(null, resolvedValue);
      });
    };
  };

  /*
  #   Resolve Value Functor
  #   Convert a js value into js attribute, array, hash, or model
  #   obj: The object that will have its key set to the resolved value
  #   optionally sets the val to the specified key on object (if obj and key are given)
  #   otherwise, this functor is expected to run in an async call, and will receive an array of results when complete
  */


  resolveValueFunctorFor = function(klazz, val, obj, key) {
    return function(cb) {
      return klazz.rorm_resolveValue(val, function(err, resolvedValue) {
        if ((obj != null) && (key != null)) {
          obj[key] = resolvedValue;
        }
        return cb(null, resolvedValue);
      });
    };
  };

  RedisORM = (function(_super) {

    __extends(RedisORM, _super);

    function RedisORM() {
      return RedisORM.__super__.constructor.apply(this, arguments);
    }

    RedisORM.addTheseToClass = {
      /*
          #   Some Constants
      */

      rorm_delim: ':',
      rorm_prefix: 'orm:',
      /*
          #   db
          #   returns a redis client bound to redisURL:dbNum
          #   the redis client can is cached globally by redisURL:dbNum
          #   defaults redisURL to redis::localhost:6379
          #   defaults dbNum to 0
      */

      rorm_redis: function() {
        var dbNum, lookup, url;
        if (this.mixinConfig.client != null) {
          return this.mixinConfig.client;
        }
        url = this.mixinConfig.url || global.redisURL || global.REDIS_URL || process.env.REDIS_URL || process.env.REDISTOGO_URL || 'redis://127.0.0.1:6379/';
        dbNum = this.mixinConfig.dbNum || global.dbNum || 0;
        lookup = "" + url + "[" + dbNum + "]";
        return rorm_redisClients[lookup] || (rorm_redisClients[lookup] = (require('redis-url')).connect(url).select(dbNum));
      },
      configureRedisORM: function(configs) {
        var key, val, _results;
        _results = [];
        for (key in configs) {
          if (!__hasProp.call(configs, key)) continue;
          val = configs[key];
          _results.push(this.mixinConfig[key] = val);
        }
        return _results;
      },
      field: function(name, options) {
        var _ref, _ref1, _ref2, _ref3;
        if (!isHash(options)) {
          return;
        }
        if ((options.list != null) || ((_ref = options.type) != null ? _ref.downcase() : void 0) === 'list') {
          this.dbFieldList(name, options);
        }
        if ((options.hash != null) || ((_ref1 = options.type) != null ? _ref1.downcase() : void 0) === 'hash') {
          this.dbFieldHash(name, options);
        }
        if (((options.set != null) && (options.sorted != null)) || ((_ref2 = options.type) != null ? _ref2.downcase() : void 0) === 'sortedset') {
          this.dbFieldSortedSet(name, options);
        }
        if (((options.set != null) && !(options.sorted != null)) || ((_ref3 = options.type) != null ? _ref3.downcase() : void 0) === 'set') {
          return this.dbFieldSet(name, options);
        }
      },
      dbFieldList: function(name, options) {
        return console.log('definging dbFieldList called ', name);
      },
      dbFieldHash: function(name, options) {
        return console.log('definging dbFieldHash called ', name);
      },
      dbFieldSet: function(name, options) {
        return console.log('definging dbFieldSet called ', name);
      },
      dbFieldSortedSet: function(name, options) {
        return console.log('definging dbFieldSortedSet called ', name);
      },
      materialize: function(idOrHash, callback) {
        var id,
          _this = this;
        if (idOrHash == null) {
          return callback(NO_ID);
        }
        id = (idOrHash.id != null) || (typeof idOrHash.toString === "function" ? idOrHash.toString() : void 0);
        if (id == null) {
          return callback(NO_ID);
        }
        return this.find(id, function(err, obj) {
          var item;
          if (err != null) {
            return callback(err);
          }
          if (obj != null) {
            obj.initializeFields(idOrHash);
            if (obj) {
              return callback(null, obj);
            }
          }
          item = new _this;
          item.initializeFields(idOrHash);
          return callback(null, item);
        });
      },
      find: function(id, callback) {
        var refKey;
        refKey = this.rorm_refKeyForID(id);
        return this.rorm_findByRefKey(refKey, callback);
      },
      rorm_classForRefKey: function(key) {
        var className;
        className = key.split(':')[1];
        return global[className];
      },
      rorm_findByRefKey: function(key, callback) {
        var _this = this;
        return this.rorm_redis().hgetall(key, function(err, data) {
          var klazz, x;
          if (data == null) {
            return callback(err, null);
          }
          klazz = _this.rorm_classForRefKey(key);
          x = new klazz;
          return _this.rorm_resolveHashJSONValues(klazz, x, data, callback);
        });
      },
      rorm_resolveHashJSONValues: function(klazz, targetHashObj, unresolvedHash, callback) {
        var k, resolvers, v;
        resolvers = [];
        for (k in unresolvedHash) {
          if (!__hasProp.call(unresolvedHash, k)) continue;
          v = unresolvedHash[k];
          resolvers.push(resolveJSONFunctorFor(klazz, v, targetHashObj, k));
        }
        return async.series(resolvers, function(err, results) {
          return callback(err, targetHashObj);
        });
      },
      rorm_resolveJSONValue: function(val, callback) {
        var v;
        v = void 0;
        try {
          v = JSON.parse(val);
        } catch (e) {
          v = void 0;
        }
        return this.rorm_resolveValue(v, callback);
      },
      rorm_resolveValue: function(val, callback) {
        if ('string' === typeof val && val.startsWith(this.rorm_prefix)) {
          return this.rorm_findByRefKey(val, callback);
        } else if (val instanceof Array) {
          return this.rorm_deepLookupRefsInArray(val, callback);
        } else if (isHash(val)) {
          return this.rorm_deepLookupRefsInHash(val, callback);
        } else {
          return callback(null, val);
        }
      },
      rorm_deepLookupRefsInHash: function(unresolvedHash, callback) {
        var k, resolvers, targetHashObj, v;
        targetHashObj = {};
        resolvers = [];
        for (k in unresolvedHash) {
          if (!__hasProp.call(unresolvedHash, k)) continue;
          v = unresolvedHash[k];
          resolvers.push(resolveValueFunctorFor(this, v, targetHashObj, k));
        }
        return async.series(resolvers, function(err, results) {
          return callback(err, targetHashObj);
        });
      },
      rorm_deepLookupRefsInArray: function(unresolvedArray, callback) {
        var resolvers, v, _i, _len;
        resolvers = [];
        for (_i = 0, _len = unresolvedArray.length; _i < _len; _i++) {
          v = unresolvedArray[_i];
          resolvers.push(resolveValueFunctorFor(this, v));
        }
        return async.series(resolvers, function(err, results) {
          return callback(err, results);
        });
      },
      rorm_save: function(model, expire, callback) {
        var seconds,
          _this = this;
        if (!model.id) {
          throw NO_ID;
        }
        if (!(callback != null) && typeof expire === TYPE_FUNCTION) {
          callback = expire;
          expire = -1;
        }
        seconds = parseInt(expire);
        return this.rorm_deepSaveAtts(model, function(err, key) {
          if (0 < seconds) {
            return _this.rorm_expire(model, seconds, function(err, ok) {
              if (callback != null) {
                return callback(err, key);
              }
            });
          } else {
            if (callback != null) {
              return callback(err, key);
            }
          }
        });
      },
      rorm_expire: function(model, seconds, callback) {
        var key;
        key = this.rorm_refKeyForModel(model);
        this.rorm_redis().expire(key, seconds, callback);
        return key;
      },
      rorm_persist: function(model, callback) {
        var key;
        key = this.rorm_refKeyForModel(model);
        this.rorm_redis().persist(key, callback);
        return key;
      },
      rorm_destroy: function(model, callback) {
        var key,
          _this = this;
        if (!model.id) {
          throw NO_ID;
        }
        key = model.rorm_refKey();
        this.rorm_redis().del(key, function(err, ok) {
          if (callback) {
            return callback(err, key);
          }
        });
        return key;
      },
      /*
          #   deepSaveAtts
          #   deeply stores the all object atts to redis using:
          #   REDIS.HMSET key, att1, val1 [,att2, val2 ...]
          #   return: redis key
      */

      rorm_deepSaveAtts: function(model, callback) {
        var atts, redisArgs, redisAtts, _ref,
          _this = this;
        atts = this.rorm_attsForModel(model);
        redisAtts = this.rorm_deepSaveHashValues(atts);
        redisArgs = this.rorm_argsForHMSET(model.rorm_refKey(), redisAtts);
        (_ref = this.rorm_redis()).hmset.apply(_ref, __slice.call(redisArgs).concat([function(err, ok) {
          if (callback != null) {
            return callback(err, redisArgs[0]);
          }
        }]));
        return redisArgs[0];
      },
      /* 
      #   rorm_argsForHMSET
      #   prepars an argument array for call to:
      #   REDIS.HMSET key field value [field value ...]
      */

      rorm_argsForHMSET: function(redisKey, atts) {
        var args, k, v;
        args = [];
        args.push(redisKey);
        for (k in atts) {
          if (!__hasProp.call(atts, k)) continue;
          v = atts[k];
          args.push(k, JSON.stringify(v));
        }
        return args;
      },
      rorm_refKeyForModel: function(model) {
        return this.rorm_refKeyForID(model.id, model.constructor.name);
      },
      rorm_refKeyForID: function(id, className) {
        className || (className = this.name);
        return this.rorm_prefix + className + this.rorm_delim + id;
      },
      rorm_attsForModel: function(model) {
        var _this = this;
        return subsetOfHash(model, function(key, value) {
          return !(key.startsWith('rorm_')) && (typeof value !== TYPE_FUNCTION);
        });
      },
      rorm_deepSaveHashValues: function(atts) {
        var _this = this;
        return mapOfHash(atts, function(key, val) {
          var mappedValue;
          if (typeof val === TYPE_FUNCTION) {
            throw NOT_A_MODEL;
          }
          if (val === null) {
            return [key, null];
          }
          if (val === void 0) {
            return [key, void 0];
          }
          if (val instanceof Array) {
            mappedValue = _this.rorm_deepSaveArrayValues(val);
          } else if (isHash(val)) {
            mappedValue = _this.rorm_deepSaveHashValues(val);
          } else {
            mappedValue = (typeof val.save === "function" ? val.save() : void 0) || val;
          }
          return [key, mappedValue];
        });
      },
      rorm_deepSaveArrayValues: function(array) {
        var item, val, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          val = array[_i];
          if (typeof val === TYPE_FUNCTION) {
            throw NOT_A_MODEL;
          }
          if (val === null) {
            item = null;
          }
          if (val === void 0) {
            item = void 0;
          }
          if (val instanceof Array) {
            item = this.rorm_deepSaveArrayValues(val);
            _results.push(item);
          } else if (isHash(val)) {
            _results.push(item = this.rorm_deepSaveHashValues(val));
          } else {
            _results.push(item = (typeof val.save === "function" ? val.save() : void 0) || val);
          }
        }
        return _results;
      }
    };

    RedisORM.addTheseToInstance = {
      rorm_class: function() {
        return this.constructor;
      },
      rorm_refKey: function() {
        return this.rorm_class().rorm_refKeyForModel(this);
      },
      /*
          #   save
          #   stores the object's state in redis
          #   an @id is auto generated if one isn't set already
          #   return: redis key
          #   creates a key based on @id, and saves the object into redis
          #   values are saved as json
          #   refs as redis keys to the object (which all start with the rorm_prefix)
      */

      save: function(expireInSeconds, callback) {
        return this.rorm_class().rorm_save(this, expireInSeconds, callback);
      },
      initializeFields: function(fieldsHash) {
        var key, val, _results;
        if (!((fieldsHash != null) && isHash(fieldsHash))) {
          return;
        }
        _results = [];
        for (key in fieldsHash) {
          if (!__hasProp.call(fieldsHash, key)) continue;
          val = fieldsHash[key];
          _results.push(this[key] = val);
        }
        return _results;
      },
      expire: function(seconds, callback) {
        return this.rorm_class().rorm_expire(this, seconds, callback);
      },
      persist: function(callback) {
        return this.rorm_class().rorm_persist(this, callback);
      },
      destroy: function(callback) {
        return this.rorm_class().rorm_destroy(this, callback);
      },
      /*
          #   toHash
          #   copy of all the model's attributes
      */

      toHash: function() {
        return this.rorm_class().rorm_attsForModel(this);
      },
      toJSON: function() {
        return JSON.stringify(this.toHash());
      },
      toEvent: function() {
        var atts, fieldName, _i, _len, _ref;
        atts = this.toHash();
        if (this.privateFields != null) {
          _ref = this.privateFields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            fieldName = _ref[_i];
            delete atts[fieldName];
          }
        }
        return atts;
      },
      emitTo: function(channel) {
        var _ref, _ref1;
        if (((_ref = channel.manager) != null ? (_ref1 = _ref.settings) != null ? _ref1.transports : void 0 : void 0) != null) {
          return channel.emit(this.className(), this.toEvent());
        } else {
          return channel.emit(this.className(), this);
        }
      }
    };

    return RedisORM;

  })(Mixin);

  global.RedisORM = RedisORM;

}).call(this);
